/*
## Summary
(NOT FULLY IMPLEMENTED). Compiles data for the ERA performance rating indicator.

## Description 
This uses the new methods suggested in the ERA 2023 Consultation Paper. 
See: https://github.com/Curtin-Open-Knowledge-Initiative/coki-ries/blob/main/docs/era_2023.md

There are three ratings methods used:

- RCI Dynamic: a class category based on dynamic RCI calculation against global outputs (world benchmark)
- HPI Option A: mixes together the HPB and WB benchmarks to assign a rating.
- HPI Option B: uses either the HPB or WB benchmark to assign a rating (does not mix them).

## Contacts
julian.tonti-filippini@curtin.edu.au

## License
Apache 2.0

## Requires
table rci_grouping_*

## Creates
table ratings_*

*/
const compile = ({
  ns_core = 'project.dataset',
  scope   = 'world',
  digits  = 4,
  start   = 2016,
  finish  = 2021,
  replace = false,
}) => `
-- generated by: ${require('path').basename(__filename)}
BEGIN
  /* currently inactivated
  ${replace ? 'CREATE OR REPLACE TABLE' : 'CREATE TABLE IF NOT EXISTS'} \`${ns_core}.rci_scores_${scope}_${digits}\` AS ( 
    WITH ror_for_year AS (
      SELECT 
        A.ror,
        B.vers,
        B.code,
        C.year_published   AS year,
        COUNT(1)           AS num_papers,
        SUM(B.weight)      AS sum_portions,
        SUM(num_citations) AS num_citations,
        ROUND(AVG(num_citations),4) AS avg_citations 
      FROM       \`${ns_core}.paper_x_hep\`     AS A 
      INNER JOIN \`${ns_core}.forcode_x_paper\` AS B ON A.doi = B.doi AND B.vers = 2020 AND LENGTH(code) = ${digits} -- filter for codes
      INNER JOIN \`${ns_core}.papers\`          AS C ON A.doi = C.doi AND year_published BETWEEN ${start} AND ${finish} -- filter time frame
      GROUP BY ror, vers, code, year 
      ORDER BY num_citations DESC
    ),

    -- generate aggregate stats across the time period for each (RoR,FoR). Needed for low-volume filtering
    -- FIXME: is paper deduplication required here?
    ror_for AS (
      SELECT 
        ror,
        vers,
        code,
        ROUND(SUM(sum_portions),4) AS sum_portions,
        SUM(sum_portions) < 50 AS low_volume,
        SUM(num_papers) AS num_papers,
        SUM(num_citations) AS num_citations,
        ROUND(SUM(num_citations) / SUM(num_papers),4) AS avg_citations
      FROM ror_for_year 
      GROUP BY ror,vers,code 
      ORDER BY sum_portions DESC
    ),

    -- filter the first table to exclude institutions that don't pass the volume threshold
    ror_for_year_rank AS (
      SELECT 
        A.ror,
        A.vers,
        A.code,
        A.year,
        A.num_papers,
        A.num_citations
      FROM ror_for_year  AS A
      INNER JOIN ror_for AS B ON A.ror = B.ror AND A.vers = B.vers AND A.code = B.code AND NOT B.low_volume
      ORDER BY vers, code, year, num_citations DESC
    ),

    -- bring in benchmark data
    with_benchmarks AS (
      SELECT 
        A.ror,
        B.name AS institution,
        A.vers,
        A.code,
        D.name AS field,
        A.year,
        ROUND(A.num_citations / A.num_papers,2) AS cpp,
        ROUND(C.cpp_benchmark,2) AS hpi_benchmark,
        ROUND(E.benchmark,2) AS rci_benchmark
      FROM ror_for_year_rank AS A
      LEFT JOIN \`${ns_core}.core_heps\`            AS B ON A.ror  = B.ror
      LEFT JOIN \`${ns_core}.core_fors\`            AS D ON A.vers = D.vers AND A.code = D.code
      LEFT JOIN \`${ns_core}.benchmarks_hpi\`       AS C ON A.vers = C.vers AND A.code = C.code AND A.year = C.year 
      LEFT JOIN \`${ns_core}.rci_benchmarks_world\` AS E ON A.vers = E.vers AND A.code = E.code AND A.year = E.year_published
    )
    SELECT 
      *,
      IF(cpp IS NULL OR hpi_benchmark IS NULL OR hpi_benchmark = 0, 0, ROUND(cpp / hpi_benchmark,2)) AS relative_hpi,
      IF(cpp IS NULL OR rci_benchmark IS NULL OR rci_benchmark = 0, 0, ROUND(cpp / rci_benchmark,2)) AS relative_rci
    FROM with_benchmarks
  );
  -- ALTER TABLE ${ns_core}.ind_ratings
  -- ALTER COLUMN ror
  -- ALTER COLUMN name
  -- ALTER COLUMN vers             SET OPTIONS (description="Field of Research (FoR) version year (either 2008 or 2020)"),
  -- ALTER COLUMN code             SET OPTIONS (description="Field of Research (FoR) code (2-digit or 4-digit)"),
  -- ALTER COLUMN year             SET OPTIONS (description="Year of consideration (research outputs published in this year)"),
  */

  -- assign ratings
  ${replace ? 'CREATE OR REPLACE TABLE' : 'CREATE TABLE IF NOT EXISTS'} \`${ns_core}.ratings_${scope}_${digits}\` AS (
    SELECT 
      institution,
      field,
      year,
      rci_world,
      CASE
        WHEN rci_world > 1.6 THEN '5 - well above world standard'
        WHEN rci_world > 1.2 THEN '4 - above world standard'
        WHEN rci_world > 0.8 THEN '3 - around world standard'
        WHEN rci_world > 0.4 THEN '2 - below world standard'
        WHEN rci_world > 0 THEN '1 - well below world standard'
        ELSE 'NA - not assessable'
      END AS rating_world,
      CASE
        WHEN hpi_world > 1.6 AND rci_world > 1.6 THEN '5 - world leading'
        WHEN hpi_world > 0.8 AND rci_world > 1.6 THEN '4 - well above world standard'
        WHEN hpi_world < 0.8 AND rci_world > 1.2 THEN '3 - above world standard' 
        WHEN rci_world > 0.8 THEN '2 - world standard'
        WHEN rci_world > 0 THEN '1 - not at world standard'
        ELSE 'NA - not assessable'
      END AS rating_option_a,
      CASE
        WHEN hpi_world > 1.6 THEN 'AAA - world leading'
        WHEN hpi_world > 1.2 THEN 'AA - above high performance standard'
        WHEN hpi_world > 0.8 THEN 'A - around high performance standard'
        WHEN rci_world > 1.2 THEN 'B - above world standard'
        WHEN rci_world > 0.8 THEN 'C - around world standard'
        WHEN rci_world > 0 THEN 'D - below world standard'
        ELSE 'NA - not assessable'
      END AS rating_option_b
    FROM ${ns_core}.rci_grouping_${scope}_${digits}_institution_field_year
    ORDER BY rci_world DESC 
  );
END;
`;
const compile_all = (args={}) => [ 
  compile({ ...args, scope:'world', digits:4 }),
  compile({ ...args, scope:'world', digits:2 }),
  compile({ ...args, scope:'local', digits:4 }),
  compile({ ...args, scope:'local', digits:2 }),
];
module.exports = { compile, compile_all };
if (require.main === module) require('app').cli_compile(compile_all);
